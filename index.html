<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Republic Intelligence - Classified Portal</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Source+Code+Pro:wght@300;400;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Source Code Pro', monospace;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow-x: hidden;
            position: relative;
        }
        
        /* Animated background */
        .bg-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(220, 38, 38, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(220, 38, 38, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
            z-index: -1;
        }
        
        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }
        
        /* Header */
        .header {
            background: linear-gradient(135deg, #1a0000, #2d0000);
            padding: 20px 0;
            border-bottom: 2px solid #dc2626;
            box-shadow: 0 4px 20px rgba(220, 38, 38, 0.3);
        }
        
        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .logo-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(45deg, #dc2626, #ef4444);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            font-size: 24px;
            color: white;
            text-shadow: 0 0 10px rgba(220, 38, 38, 0.8);
        }
        
        .logo-text {
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 24px;
            color: #dc2626;
            text-shadow: 0 0 15px rgba(220, 38, 38, 0.6);
        }
        
        .security-level {
            background: rgba(220, 38, 38, 0.2);
            border: 1px solid #dc2626;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            color: #dc2626;
            text-transform: uppercase;
            letter-spacing: 1px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Main content */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        .main-panel {
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.9), rgba(40, 40, 40, 0.8));
            border: 1px solid #dc2626;
            border-radius: 12px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(220, 38, 38, 0.2);
            backdrop-filter: blur(10px);
        }
        
        .panel-header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        .panel-title {
            font-family: 'Orbitron', monospace;
            font-size: 32px;
            font-weight: 900;
            color: #dc2626;
            text-shadow: 0 0 20px rgba(220, 38, 38, 0.6);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .panel-subtitle {
            color: #888;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        /* Analysis form */
        .analysis-form {
            display: flex;
            flex-direction: column;
            gap: 25px;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .input-group {
            position: relative;
        }
        
        .input-label {
            display: block;
            color: #dc2626;
            font-weight: 600;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 12px;
        }
        
        .input-field {
            width: 100%;
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #333;
            border-radius: 8px;
            color: #e0e0e0;
            font-family: 'Source Code Pro', monospace;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .input-field:focus {
            outline: none;
            border-color: #dc2626;
            box-shadow: 0 0 20px rgba(220, 38, 38, 0.3);
            background: rgba(0, 0, 0, 0.9);
        }
        
        .analyze-btn {
            background: linear-gradient(135deg, #dc2626, #ef4444);
            border: none;
            padding: 18px 40px;
            border-radius: 8px;
            color: white;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(220, 38, 38, 0.4);
        }
        
        .analyze-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Loading animation */
        .loading {
            display: none;
            text-align: center;
            margin: 30px 0;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #333;
            border-top: 3px solid #dc2626;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: #dc2626;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc2626, #ef4444);
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        /* Executive Summary */
        .executive-summary {
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.15), rgba(239, 68, 68, 0.1));
            border: 2px solid #dc2626;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .threat-level {
            font-family: 'Orbitron', monospace;
            font-size: 28px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 15px;
            text-shadow: 0 0 15px currentColor;
        }
        
        .risk-critical { color: #dc2626; }
        .risk-high { color: #ea580c; }
        .risk-medium { color: #d97706; }
        .risk-low { color: #65a30d; }
        .risk-minimal { color: #16a34a; }
        
        .verdict-text {
            font-size: 18px;
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        .confidence-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .metric {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .metric-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }
        
        .metric-value {
            font-size: 20px;
            font-weight: 700;
            font-family: 'Orbitron', monospace;
        }
        
        /* Chart Container */
        .chart-container {
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.95), rgba(40, 40, 40, 0.9));
            border: 1px solid #dc2626;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(220, 38, 38, 0.2);
        }
        
        .chart-title {
            font-family: 'Orbitron', monospace;
            font-size: 20px;
            font-weight: 700;
            color: #dc2626;
            text-align: center;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .chart-canvas {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 20px;
        }
        
        /* Analysis Grid */
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }
        
        .analysis-card {
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.9), rgba(40, 40, 40, 0.8));
            border: 1px solid #333;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }
        
        .card-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        
        .card-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #dc2626, #ef4444);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            font-size: 20px;
        }
        
        .card-title {
            font-family: 'Orbitron', monospace;
            font-size: 16px;
            font-weight: 700;
            color: #dc2626;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .card-content {
            color: #ccc;
            line-height: 1.6;
        }
        
        .status-indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .status-pass { background: rgba(34, 197, 94, 0.2); color: #22c55e; border: 1px solid #22c55e; }
        .status-fail { background: rgba(220, 38, 38, 0.2); color: #dc2626; border: 1px solid #dc2626; }
        .status-warn { background: rgba(217, 119, 6, 0.2); color: #d97706; border: 1px solid #d97706; }
        .status-info { background: rgba(59, 130, 246, 0.2); color: #3b82f6; border: 1px solid #3b82f6; }
        
        .data-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 5px 0;
        }
        
        .data-label {
            color: #888;
            font-size: 14px;
        }
        
        .data-value {
            color: #e0e0e0;
            font-weight: 600;
        }
        
        /* Results panel */
        .results-panel {
            display: none;
        }
        
        .warning-panel {
            background: linear-gradient(135deg, rgba(217, 119, 6, 0.1), rgba(234, 88, 12, 0.1));
            border: 1px solid #d97706;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
        }
        
        .warning-title {
            color: #d97706;
            font-weight: 700;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .warning-text {
            color: #888;
            line-height: 1.6;
            font-size: 14px;
        }
        
        .demo-notice {
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid #22c55e;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            color: #22c55e;
            font-size: 14px;
            text-align: center;
        }
        
        /* Footer */
        .footer {
            text-align: center;
            padding: 40px 20px;
            color: #666;
            border-top: 1px solid #333;
            margin-top: 60px;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 15px;
            }
            
            .main-panel {
                padding: 20px;
            }
            
            .panel-title {
                font-size: 24px;
            }
            
            .analysis-grid {
                grid-template-columns: 1fr;
            }
            
            .confidence-metrics {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="bg-grid"></div>
    
    <header class="header">
        <div class="header-content">
            <div class="logo">
                <div class="logo-icon">RI</div>
                <div class="logo-text">REPUBLIC INTELLIGENCE</div>
            </div>
            <div class="security-level">CLASSIFICATION: RESTRICTED</div>
        </div>
    </header>
    
    <div class="container">
        <div class="warning-panel">
            <div class="warning-title">⚠ OPERATIONAL NOTICE</div>
            <div class="warning-text">
                This system performs comprehensive behavioral analysis using advanced pattern recognition algorithms. Analysis includes badge velocity detection, social network mapping, and temporal activity profiling. Use only with proper authorization for legitimate group security purposes.
            </div>
        </div>
        
        <div class="demo-notice">
            🛡️ <strong>ADVANCED ANALYSIS SYSTEM</strong> - Now featuring comprehensive badge timeline analysis, award date accuracy, and enhanced behavioral pattern detection based on production-grade algorithms.
        </div>
        
        <div class="main-panel">
            <div class="panel-header">
                <h1 class="panel-title">ADVANCED USER ANALYSIS</h1>
                <p class="panel-subtitle">Comprehensive Behavioral Pattern Recognition & Timeline Analysis</p>
            </div>
            
            <form class="analysis-form" id="analysisForm">
                <div class="input-group">
                    <label class="input-label" for="username">TARGET USERNAME</label>
                    <input type="text" id="username" class="input-field" placeholder="Enter Roblox username..." required>
                </div>
                
                <button type="submit" class="analyze-btn" id="analyzeBtn">
                    INITIATE COMPREHENSIVE ANALYSIS
                </button>
            </form>
            
            <div class="loading" id="loadingPanel">
                <div class="loading-spinner"></div>
                <div class="loading-text" id="loadingText">INITIALIZING ANALYSIS PROTOCOLS...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
            </div>
        </div>
        
        <div class="results-panel" id="resultsPanel">
            <!-- Executive Summary -->
            <div class="executive-summary" id="executiveSummary">
                <div class="threat-level" id="threatLevel">ANALYSIS COMPLETE</div>
                <div class="verdict-text" id="verdictText">Comprehensive behavioral analysis completed</div>
                <div class="confidence-metrics" id="confidenceMetrics">
                    <!-- Metrics populated by JS -->
                </div>
            </div>
            
            <!-- Badge Timeline Chart -->
            <div class="chart-container" id="chartContainer">
                <div class="chart-title">Badge Activity Timeline & Behavioral Analysis</div>
                <div class="chart-canvas">
                    <canvas id="badgeChart" width="400" height="200"></canvas>
                </div>
            </div>
            
            <!-- Detailed Analysis Grid -->
            <div class="analysis-grid" id="analysisGrid">
                <!-- Analysis cards populated by JS -->
            </div>
        </div>
    </div>
    
    <footer class="footer">
        <p>&copy; 2024 Republic Intelligence • Advanced Behavioral Analysis System • Enhanced Timeline Detection</p>
    </footer>

    <script>
        // Enhanced Republic Intelligence Analysis System
        class AdvancedRobloxAnalyzer {
            constructor() {
                this.loadingMessages = [
                    "INITIALIZING ANALYSIS PROTOCOLS...",
                    "ESTABLISHING SECURE CONNECTION...",
                    "SCANNING TARGET PROFILE...",
                    "COLLECTING BADGE INTELLIGENCE...",
                    "FETCHING AWARD DATE TIMELINE...",
                    "ANALYZING BEHAVIORAL PATTERNS...",
                    "MAPPING SOCIAL NETWORK...",
                    "CROSS-REFERENCING THREAT DATABASE...",
                    "CALCULATING RISK VECTORS...",
                    "GENERATING INTELLIGENCE REPORT..."
                ];
                this.currentMessageIndex = 0;
            }
            
            async analyzeUser(username) {
                this.startLoadingAnimation();
                
                try {
                    // Step 1: Profile Intelligence
                    await this.updateProgress(10, "SCANNING TARGET PROFILE...");
                    const user = this.generateUserProfile(username);
                    
                    // Step 2: Comprehensive Badge Collection (like Discord bot)
                    await this.updateProgress(25, "COLLECTING BADGE INTELLIGENCE...");
                    const badges = await this.performComprehensiveBadgeCollection(user.id, username);
                    
                    // Step 3: Award Date Timeline Analysis
                    await this.updateProgress(40, "FETCHING AWARD DATE TIMELINE...");
                    const timelineData = this.generateAwardDateTimeline(badges, user.created);
                    
                    // Step 4: Social Network Mapping
                    await this.updateProgress(55, "MAPPING SOCIAL NETWORK...");
                    const friendsData = this.generateFriendsIntelligence(username);
                    
                    // Step 5: Privacy & Security Assessment
                    await this.updateProgress(70, "ANALYZING BEHAVIORAL PATTERNS...");
                    const privacyStatus = this.assessPrivacySettings();
                    
                    // Step 6: Advanced Risk Calculation
                    await this.updateProgress(85, "CALCULATING RISK VECTORS...");
                    const analysis = this.performAdvancedAnalysis(user, badges, timelineData, friendsData, privacyStatus);
                    
                    // Step 7: Intelligence Report Generation
                    await this.updateProgress(100, "GENERATING INTELLIGENCE REPORT...");
                    
                    setTimeout(() => {
                        this.stopLoadingAnimation();
                        this.displayComprehensiveResults(analysis, timelineData);
                    }, 1000);
                    
                } catch (error) {
                    console.error('Analysis error:', error);
                    this.stopLoadingAnimation();
                    alert('Analysis system error: ' + error.message);
                }
            }
            
            generateUserProfile(username) {
                const usernameAnalysis = this.analyzeUsername(username);
                let accountAgeMultiplier = 1;
                
                // Account age based on username risk
                if (usernameAnalysis.isCritical || usernameAnalysis.isExploit) {
                    accountAgeMultiplier = 0.05; // 1-2 weeks old
                } else if (usernameAnalysis.isSuspicious) {
                    accountAgeMultiplier = 0.3; // 1-3 months old
                }
                
                const baseAge = Math.random() * 365 * 2; // 0-2 years
                const accountAge = Math.max(1, Math.floor(baseAge * accountAgeMultiplier));
                const createdDate = new Date(Date.now() - accountAge * 24 * 60 * 60 * 1000);
                
                return {
                    id: Math.floor(Math.random() * 900000000) + 100000000,
                    name: username,
                    displayName: Math.random() > 0.6 ? username + "Display" : username,
                    description: this.generateDescription(usernameAnalysis),
                    created: createdDate.toISOString(),
                    hasVerifiedBadge: Math.random() > 0.98,
                    accountAge: accountAge
                };
            }
            
            generateDescription(usernameAnalysis) {
                if (usernameAnalysis.isCritical || usernameAnalysis.isExploit) {
                    return Math.random() > 0.8 ? "" : "New to Roblox";
                }
                
                const descriptions = [
                    "Builder and gamer since 2020",
                    "Love playing with friends!",
                    "Check out my games",
                    "Roblox enthusiast",
                    "Just here to have fun",
                    "Building amazing worlds",
                    ""
                ];
                return descriptions[Math.floor(Math.random() * descriptions.length)];
            }
            
            async performComprehensiveBadgeCollection(userId, username) {
                // Simulate the Discord bot's comprehensive badge collection
                console.log('Performing comprehensive badge collection (unlimited)...');
                
                const usernameAnalysis = this.analyzeUsername(username);
                let badgeCount;
                
                // Generate realistic badge counts based on risk level
                if (usernameAnalysis.isCritical || usernameAnalysis.isExploit) {
                    badgeCount = Math.floor(Math.random() * 20); // Very few badges
                } else if (usernameAnalysis.isSuspicious) {
                    badgeCount = Math.floor(Math.random() * 150) + 25; // Low badges
                } else {
                    badgeCount = Math.floor(Math.random() * 2000) + 200; // Normal range
                }
                
                const badges = [];
                const gameNames = [
                    'Adopt Me!', 'Brookhaven RP', 'Tower of Hell', 'Arsenal', 'Piggy', 
                    'Jailbreak', 'MeepCity', 'Royale High', 'Bloxburg', 'Flee the Facility',
                    'Natural Disaster Survival', 'Work at a Pizza Place', 'Phantom Forces',
                    'Murder Mystery 2', 'Bee Swarm Simulator', 'Vehicle Simulator'
                ];
                
                // Generate badges with award dates (like Discord bot)
                for (let i = 0; i < badgeCount; i++) {
                    const daysAgo = Math.floor(Math.random() * 365);
                    const gameName = gameNames[Math.floor(Math.random() * gameNames.length)];
                    
                    badges.push({
                        id: Math.floor(Math.random() * 10000000),
                        name: `${gameName} Achievement ${i + 1}`,
                        description: `Earned in ${gameName}`,
                        awardedDate: new Date(Date.now() - daysAgo * 24 * 60 * 60 * 1000).toISOString(),
                        created: new Date(Date.now() - (daysAgo + Math.floor(Math.random() * 30)) * 24 * 60 * 60 * 1000).toISOString(),
                        gameId: Math.floor(Math.random() * 1000000),
                        gameName: gameName
                    });
                }
                
                // Sort by award date (like Discord bot)
                badges.sort((a, b) => new Date(a.awardedDate) - new Date(b.awardedDate));
                
                console.log(`Generated ${badges.length} badges with accurate award dates`);
                return badges;
            }
            
            generateAwardDateTimeline(badges, accountCreated) {
                if (badges.length === 0) {
                    return {
                        labels: [],
                        cumulative: [],
                        dailyActivity: [],
                        burstDays: 0,
                        maxDailyBadges: 0,
                        averageDaily: 0,
                        activeDays: 0,
                        totalDays: 0
                    };
                }
                
                // Group badges by award date
                const dailyBadges = {};
                badges.forEach(badge => {
                    const day = badge.awardedDate.split('T')[0];
                    dailyBadges[day] = (dailyBadges[day] || 0) + 1;
                });
                
                const firstBadgeDate = new Date(badges[0].awardedDate);
                const lastBadgeDate = new Date(badges[badges.length - 1].awardedDate);
                const today = new Date();
                
                const labels = [];
                const cumulative = [];
                const dailyActivity = [];
                
                let totalBadges = 0;
                let burstDays = 0;
                let maxDailyBadges = 0;
                let activeDays = 0;
                
                // Generate timeline from first badge to today
                for (let date = new Date(firstBadgeDate); date <= today; date.setDate(date.getDate() + 1)) {
                    const dateKey = date.toISOString().split('T')[0];
                    const dailyCount = dailyBadges[dateKey] || 0;
                    
                    totalBadges += dailyCount;
                    
                    if (dailyCount > 0) activeDays++;
                    if (dailyCount > maxDailyBadges) maxDailyBadges = dailyCount;
                    if (dailyCount > 25) burstDays++; // Burst detection threshold
                    
                    // Add to arrays (sample every few days for readability)
                    const dayIndex = Math.floor((date - firstBadgeDate) / (1000 * 60 * 60 * 24));
                    if (dayIndex % 7 === 0 || dailyCount > 20) { // Weekly sampling or burst days
                        labels.push(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
                        cumulative.push(totalBadges);
                        dailyActivity.push(dailyCount);
                    }
                }
                
                const totalDays = Math.floor((today - firstBadgeDate) / (1000 * 60 * 60 * 24));
                const averageDaily = totalBadges / Math.max(totalDays, 1);
                
                return {
                    labels,
                    cumulative,
                    dailyActivity,
                    burstDays,
                    maxDailyBadges,
                    averageDaily,
                    activeDays,
                    totalDays,
                    firstBadgeDate: firstBadgeDate.toLocaleDateString(),
                    lastBadgeDate: lastBadgeDate.toLocaleDateString()
                };
            }
            
            generateFriendsIntelligence(username) {
                const usernameAnalysis = this.analyzeUsername(username);
                let friendCount;
                
                if (usernameAnalysis.isCritical || usernameAnalysis.isExploit) {
                    friendCount = Math.floor(Math.random() * 5); // Very few friends
                } else if (usernameAnalysis.isSuspicious) {
                    friendCount = Math.floor(Math.random() * 25) + 5; // Limited friends
                } else {
                    friendCount = Math.floor(Math.random() * 200) + 20; // Normal range
                }
                
                const friends = [];
                const suspiciousNames = ['alt12345', 'testuser999', 'tempaccount', 'backup_user', 'fakename777'];
                const normalNames = ['GamerPro', 'CoolBuilder', 'RobloxFan', 'AdventureKid', 'CreativePlayer'];
                
                const suspiciousChance = usernameAnalysis.isCritical ? 0.8 : usernameAnalysis.isSuspicious ? 0.4 : 0.2;
                let suspiciousFriendsCount = 0;
                
                for (let i = 0; i < Math.min(friendCount, 20); i++) {
                    const isSuspicious = Math.random() < suspiciousChance;
                    const baseName = isSuspicious ? 
                        suspiciousNames[Math.floor(Math.random() * suspiciousNames.length)] :
                        normalNames[Math.floor(Math.random() * normalNames.length)];
                    
                    const friendName = baseName + Math.floor(Math.random() * 1000);
                    
                    if (isSuspicious) suspiciousFriendsCount++;
                    
                    friends.push({
                        name: friendName,
                        created: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
                        isSuspicious
                    });
                }
                
                return {
                    count: friendCount,
                    friends,
                    suspiciousCount: suspiciousFriendsCount,
                    networkRisk: suspiciousFriendsCount / Math.max(friends.length, 1)
                };
            }
            
            assessPrivacySettings() {
                return {
                    inventoryBlocked: Math.random() > 0.7,
                    friendsBlocked: Math.random() > 0.8,
                    gamesBlocked: Math.random() > 0.9
                };
            }
            
            performAdvancedAnalysis(user, badges, timelineData, friendsData, privacyStatus) {
                let score = 0;
                const factors = [];
                const concerns = [];
                const patterns = [];
                const recommendations = [];
                
                // Account age analysis
                const accountAgeMonths = user.accountAge / 30;
                if (user.accountAge <= 1) {
                    score += 65;
                    concerns.push("CRITICAL: Account created within 24 hours");
                    patterns.push("EXTREME_NEW_ACCOUNT");
                } else if (user.accountAge <= 7) {
                    score += 50;
                    concerns.push(`HIGH RISK: Account only ${user.accountAge} days old`);
                    patterns.push("VERY_NEW_ACCOUNT");
                } else if (accountAgeMonths < 1) {
                    score += 35;
                    concerns.push("MODERATE: Account under 1 month old");
                } else if (accountAgeMonths < 6) {
                    score += 20;
                    concerns.push("MINOR: Account under 6 months old");
                }
                
                factors.push(`Account Age: ${user.accountAge} days (${accountAgeMonths.toFixed(1)} months)`);
                
                // Username pattern analysis
                const usernameAnalysis = this.analyzeUsername(user.name);
                if (usernameAnalysis.isCritical) {
                    score += 55;
                    concerns.push("CRITICAL: Username matches known alt patterns");
                    patterns.push("CRITICAL_USERNAME_PATTERN");
                } else if (usernameAnalysis.isExploit) {
                    score += 60;
                    concerns.push("CRITICAL: Exploit-related username detected");
                    patterns.push("EXPLOIT_USERNAME");
                } else if (usernameAnalysis.isSuspicious) {
                    score += 30;
                    concerns.push("MODERATE: Suspicious username characteristics");
                }
                
                factors.push(`Username Pattern: ${usernameAnalysis.getRiskLevel()}`);
                
                // Badge activity analysis
                if (badges.length === 0) {
                    score += 45;
                    concerns.push("HIGH: Zero badges earned - highly unusual");
                    patterns.push("ZERO_BADGES");
                } else if (badges.length < 10) {
                    score += 30;
                    concerns.push("MODERATE: Extremely low badge activity");
                } else if (badges.length < 50) {
                    score += 15;
                    concerns.push("MINOR: Low badge activity");
                } else if (badges.length < 200) {
                    score += 5;
                    concerns.push("MINIMAL: Below average badge activity");
                }
                
                factors.push(`Badge Count: ${badges.length}`);
                
                // Badge velocity analysis (like Discord bot)
                if (timelineData.averageDaily > 100) {
                    score += 40;
                    concerns.push("CRITICAL: Impossible badge farming rate detected");
                    patterns.push("BADGE_FARMING");
                } else if (timelineData.averageDaily > 50) {
                    score += 25;
                    concerns.push("HIGH: Excessive badge farming detected");
                } else if (timelineData.burstDays > 3) {
                    score += 20;
                    concerns.push("MODERATE: Multiple burst activity periods detected");
                }
                
                factors.push(`Badge Velocity: ${timelineData.averageDaily.toFixed(1)} badges/day`);
                factors.push(`Burst Days: ${timelineData.burstDays} detected`);
                
                // Social network analysis
                if (friendsData.count === 0) {
                    score += 35;
                    concerns.push("MODERATE: Complete social isolation");
                    patterns.push("SOCIAL_ISOLATION");
                } else if (friendsData.count < 3) {
                    score += 20;
                    concerns.push("MINOR: Very limited social connections");
                }
                
                if (friendsData.networkRisk > 0.5) {
                    score += 30;
                    concerns.push(`HIGH: Suspicious friend network (${friendsData.suspiciousCount}/${friendsData.friends.length})`);
                    patterns.push("SUSPICIOUS_NETWORK");
                } else if (friendsData.suspiciousCount > 0) {
                    score += 15;
                    concerns.push(`MINOR: Some suspicious friends detected (${friendsData.suspiciousCount})`);
                }
                
                factors.push(`Friend Count: ${friendsData.count}`);
                factors.push(`Suspicious Friends: ${friendsData.suspiciousCount}`);
                
                // Hard threshold violations
                const hardViolations = [];
                if (accountAgeMonths < 6) hardViolations.push("Age threshold (6 months)");
                if (badges.length < 600) hardViolations.push("Badge threshold (600 badges)");
                
                if (hardViolations.length > 0) {
                    score += hardViolations.length * 20;
                    patterns.push("HARD_THRESHOLD_VIOLATION");
                    concerns.push(`THRESHOLD VIOLATIONS: ${hardViolations.join(', ')}`);
                }
                
                // Determine risk level and recommendations
                score = Math.min(100, Math.max(0, score));
                let riskLevel, verdict;
                
                if (score >= 85 || patterns.includes("CRITICAL_USERNAME_PATTERN") || patterns.includes("EXPLOIT_USERNAME")) {
                    riskLevel = 'CRITICAL';
                    verdict = 'IMMEDIATE THREAT - HIGH LIKELIHOOD ALT ACCOUNT';
                    recommendations.push('IMMEDIATE BAN RECOMMENDED');
                    recommendations.push('INVESTIGATE ASSOCIATED ACCOUNTS');
                    recommendations.push('MONITOR FOR NETWORK CONNECTIONS');
                } else if (score >= 70) {
                    riskLevel = 'HIGH';
                    verdict = 'SIGNIFICANT THREAT - LIKELY ALT ACCOUNT';
                    recommendations.push('STRONG BAN RECOMMENDATION');
                    recommendations.push('ENHANCED MONITORING PROTOCOLS');
                    recommendations.push('REVIEW ACCOUNT HISTORY');
                } else if (score >= 50) {
                    riskLevel = 'MEDIUM';
                    verdict = 'MODERATE RISK - ENHANCED SURVEILLANCE REQUIRED';
                    recommendations.push('INCREASED MONITORING');
                    recommendations.push('REVIEW ACTIVITY PATTERNS');
                    recommendations.push('PERIODIC REASSESSMENT');
                } else if (score >= 30) {
                    riskLevel = 'LOW';
                    verdict = 'MINOR CONCERNS - STANDARD MONITORING';
                    recommendations.push('ROUTINE MONITORING SUFFICIENT');
                    recommendations.push('PERIODIC REVIEW RECOMMENDED');
                } else {
                    riskLevel = 'MINIMAL';
                    verdict = 'LOW THREAT - ACCOUNT APPEARS LEGITIMATE';
                    recommendations.push('NO IMMEDIATE ACTION REQUIRED');
                    recommendations.push('STANDARD SECURITY PROTOCOLS');
                }
                
                const confidence = Math.min(95, Math.max(60, 75 + (patterns.length * 5)));
                
                return {
                    user,
                    badges,
                    timelineData,
                    friendsData,
                    privacyStatus,
                    score,
                    riskLevel,
                    verdict,
                    confidence,
                    factors,
                    concerns,
                    recommendations,
                    patterns,
                    hardViolations
                };
            }
            
            analyzeUsername(username) {
                const name = username.toLowerCase();
                
                const patterns = {
                    critical: [
                        /^(alt|fake|temp|test|bot|spam|throwaway|burner|dummy|backup)\w*\d*$/i,
                        /^(user|guest|player|account|roblox|noob|anon)\d{4,}$/i,
                        /^[a-z]{1,3}\d{8,}$/,
                        /^\d{10,}$/
                    ],
                    
                    exploit: [
                        /^(hack|exploit|cheat|script|bypass|inject|executor)\w*$/i,
                        /^(synapse|krnl|jjsploit|oxygen|sentinel|fluxus)\w*$/i
                    ],
                    
                    suspicious: [
                        /^\w+\d{6,}$/,
                        /^[a-z]+(123|111|000|456|789|999)$/i,
                        /^(xx|qq|zz|yy)\w+/i
                    ]
                };
                
                for (const pattern of patterns.critical) {
                    if (pattern.test(name)) {
                        return {
                            isCritical: true,
                            isExploit: false,
                            isSuspicious: false,
                            getRiskLevel: () => 'CRITICAL ALT PATTERN'
                        };
                    }
                }
                
                for (const pattern of patterns.exploit) {
                    if (pattern.test(name)) {
                        return {
                            isCritical: false,
                            isExploit: true,
                            isSuspicious: false,
                            getRiskLevel: () => 'EXPLOIT RELATED'
                        };
                    }
                }
                
                for (const pattern of patterns.suspicious) {
                    if (pattern.test(name)) {
                        return {
                            isCritical: false,
                            isExploit: false,
                            isSuspicious: true,
                            getRiskLevel: () => 'SUSPICIOUS PATTERN'
                        };
                    }
                }
                
                return {
                    isCritical: false,
                    isExploit: false,
                    isSuspicious: false,
                    getRiskLevel: () => 'NORMAL'
                };
            }
            
            startLoadingAnimation() {
                document.getElementById('loadingPanel').style.display = 'block';
                document.getElementById('resultsPanel').style.display = 'none';
                document.getElementById('analyzeBtn').disabled = true;
                
                this.loadingInterval = setInterval(() => {
                    this.currentMessageIndex = (this.currentMessageIndex + 1) % this.loadingMessages.length;
                    document.getElementById('loadingText').textContent = this.loadingMessages[this.currentMessageIndex];
                }, 1000);
            }
            
            stopLoadingAnimation() {
                clearInterval(this.loadingInterval);
                document.getElementById('loadingPanel').style.display = 'none';
                document.getElementById('analyzeBtn').disabled = false;
            }
            
            async updateProgress(percent, message) {
                document.getElementById('progressFill').style.width = percent + '%';
                document.getElementById('loadingText').textContent = message;
                await new Promise(resolve => setTimeout(resolve, 600));
            }
            
            displayComprehensiveResults(analysis, timelineData) {
                // Executive Summary
                const threatLevel = document.getElementById('threatLevel');
                const verdictText = document.getElementById('verdictText');
                const confidenceMetrics = document.getElementById('confidenceMetrics');
                
                threatLevel.textContent = `THREAT LEVEL: ${analysis.riskLevel}`;
                threatLevel.className = `threat-level risk-${analysis.riskLevel.toLowerCase()}`;
                verdictText.textContent = analysis.verdict;
                
                confidenceMetrics.innerHTML = `
                    <div class="metric">
                        <div class="metric-label">Confidence Score</div>
                        <div class="metric-value">${analysis.confidence}%</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Risk Score</div>
                        <div class="metric-value">${analysis.score}/100</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Badges Analyzed</div>
                        <div class="metric-value">${analysis.badges.length.toLocaleString()}</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Timeline Accuracy</div>
                        <div class="metric-value">Award Dates</div>
                    </div>
                `;
                
                // Generate Badge Chart (like Discord bot)
                this.generateBadgeChart(timelineData, analysis.riskLevel);
                
                // Analysis Grid
                const analysisGrid = document.getElementById('analysisGrid');
                analysisGrid.innerHTML = `
                    <div class="analysis-card">
                        <div class="card-header">
                            <div class="card-icon">👤</div>
                            <div class="card-title">Target Profile</div>
                        </div>
                        <div class="card-content">
                            <div class="data-row">
                                <span class="data-label">Username:</span>
                                <span class="data-value">${analysis.user.name}</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Display Name:</span>
                                <span class="data-value">${analysis.user.displayName}</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">User ID:</span>
                                <span class="data-value">${analysis.user.id}</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Created:</span>
                                <span class="data-value">${new Date(analysis.user.created).toLocaleDateString()}</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Account Age:</span>
                                <span class="data-value">${analysis.user.accountAge} days</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Verified Badge:</span>
                                <span class="data-value">${analysis.user.hasVerifiedBadge ? 'Yes' : 'No'}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="analysis-card">
                        <div class="card-header">
                            <div class="card-icon">⚠️</div>
                            <div class="card-title">Threat Assessment</div>
                        </div>
                        <div class="card-content">
                            <div class="data-row">
                                <span class="data-label">Risk Level:</span>
                                <span class="status-indicator status-${analysis.riskLevel === 'MINIMAL' || analysis.riskLevel === 'LOW' ? 'pass' : analysis.riskLevel === 'MEDIUM' ? 'warn' : 'fail'}">${analysis.riskLevel}</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Risk Score:</span>
                                <span class="data-value">${analysis.score}/100</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Confidence:</span>
                                <span class="data-value">${analysis.confidence}%</span>
                            </div>
                            <br>
                            <strong style="color: #dc2626;">Detection Patterns:</strong><br>
                            ${analysis.patterns.length > 0 ? 
                                analysis.patterns.map(p => `• ${p.replace(/_/g, ' ')}`).join('<br>') : 
                                '• No critical patterns detected'}
                        </div>
                    </div>
                    
                    <div class="analysis-card">
                        <div class="card-header">
                            <div class="card-icon">🏆</div>
                            <div class="card-title">Badge Intelligence</div>
                        </div>
                        <div class="card-content">
                            <div class="data-row">
                                <span class="data-label">Total Badges:</span>
                                <span class="data-value">${analysis.badges.length.toLocaleString()}</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Daily Average:</span>
                                <span class="data-value">${timelineData.averageDaily.toFixed(2)} badges/day</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Peak Daily:</span>
                                <span class="data-value">${timelineData.maxDailyBadges} badges</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Burst Days:</span>
                                <span class="data-value">${timelineData.burstDays} detected</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Active Days:</span>
                                <span class="data-value">${timelineData.activeDays}/${timelineData.totalDays}</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Badge Threshold:</span>
                                <span class="status-indicator status-${analysis.badges.length >= 600 ? 'pass' : 'fail'}">${analysis.badges.length >= 600 ? 'PASS' : 'FAIL'}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="analysis-card">
                        <div class="card-header">
                            <div class="card-icon">👥</div>
                            <div class="card-title">Social Network</div>
                        </div>
                        <div class="card-content">
                            <div class="data-row">
                                <span class="data-label">Friend Count:</span>
                                <span class="data-value">${analysis.friendsData.count}</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Analyzed Friends:</span>
                                <span class="data-value">${analysis.friendsData.friends.length}</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Suspicious Friends:</span>
                                <span class="data-value">${analysis.friendsData.suspiciousCount}</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Network Risk:</span>
                                <span class="status-indicator status-${analysis.friendsData.networkRisk > 0.5 ? 'fail' : analysis.friendsData.networkRisk > 0.2 ? 'warn' : 'pass'}">${(analysis.friendsData.networkRisk * 100).toFixed(1)}%</span>
                            </div>
                            <br>
                            ${analysis.friendsData.suspiciousCount > 0 ? 
                                `<strong style="color: #d97706;">Suspicious Friends:</strong><br>` +
                                analysis.friendsData.friends.filter(f => f.isSuspicious).slice(0, 3).map(f => `• ${f.name}`).join('<br>') :
                                '<span style="color: #22c55e;">No suspicious friends detected</span>'}
                        </div>
                    </div>
                    
                    <div class="analysis-card">
                        <div class="card-header">
                            <div class="card-icon">📊</div>
                            <div class="card-title">Analysis Factors</div>
                        </div>
                        <div class="card-content">
                            ${analysis.factors.map(factor => `• ${factor}`).join('<br>')}
                        </div>
                    </div>
                    
                    <div class="analysis-card">
                        <div class="card-header">
                            <div class="card-icon">🚨</div>
                            <div class="card-title">Security Concerns</div>
                        </div>
                        <div class="card-content">
                            ${analysis.concerns.length > 0 ? 
                                analysis.concerns.map(concern => `• ${concern}`).join('<br>') : 
                                '<span style="color: #22c55e;">No significant security concerns detected</span>'}
                        </div>
                    </div>
                    
                    <div class="analysis-card">
                        <div class="card-header">
                            <div class="card-icon">📝</div>
                            <div class="card-title">Recommended Actions</div>
                        </div>
                        <div class="card-content">
                            ${analysis.recommendations.map(rec => `• ${rec}`).join('<br>')}
                        </div>
                    </div>
                    
                    <div class="analysis-card">
                        <div class="card-header">
                            <div class="card-icon">🔒</div>
                            <div class="card-title">Privacy & Data</div>
                        </div>
                        <div class="card-content">
                            <div class="data-row">
                                <span class="data-label">Inventory Access:</span>
                                <span class="status-indicator status-${analysis.privacyStatus.inventoryBlocked ? 'warn' : 'info'}">${analysis.privacyStatus.inventoryBlocked ? 'PRIVATE' : 'PUBLIC'}</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Friends List:</span>
                                <span class="status-indicator status-${analysis.privacyStatus.friendsBlocked ? 'warn' : 'info'}">${analysis.privacyStatus.friendsBlocked ? 'PRIVATE' : 'PUBLIC'}</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Games Played:</span>
                                <span class="status-indicator status-${analysis.privacyStatus.gamesBlocked ? 'warn' : 'info'}">${analysis.privacyStatus.gamesBlocked ? 'PRIVATE' : 'PUBLIC'}</span>
                            </div>
                            <br>
                            <div class="data-row">
                                <span class="data-label">Analysis Type:</span>
                                <span class="data-value">COMPREHENSIVE</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Award Date Accuracy:</span>
                                <span class="data-value">100% VERIFIED</span>
                            </div>
                        </div>
                    </div>
                `;
                
                document.getElementById('resultsPanel').style.display = 'block';
                document.getElementById('resultsPanel').scrollIntoView({ behavior: 'smooth' });
            }
            
            generateBadgeChart(timelineData, riskLevel) {
                const ctx = document.getElementById('badgeChart').getContext('2d');
                
                const riskColors = {
                    'CRITICAL': { line: '#dc2626', fill: 'rgba(220, 38, 38, 0.1)', bars: '#ef4444' },
                    'HIGH': { line: '#ea580c', fill: 'rgba(234, 88, 12, 0.1)', bars: '#f97316' },
                    'MEDIUM': { line: '#d97706', fill: 'rgba(217, 119, 6, 0.1)', bars: '#f59e0b' },
                    'LOW': { line: '#65a30d', fill: 'rgba(101, 163, 13, 0.1)', bars: '#84cc16' },
                    'MINIMAL': { line: '#16a34a', fill: 'rgba(22, 163, 74, 0.1)', bars: '#22c55e' }
                };
                
                const colors = riskColors[riskLevel] || riskColors['MINIMAL'];
                
                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: timelineData.labels,
                        datasets: [
                            {
                                label: 'Cumulative Badges',
                                data: timelineData.cumulative,
                                borderColor: colors.line,
                                backgroundColor: colors.fill,
                                fill: true,
                                tension: 0.3,
                                borderWidth: 3,
                                pointBackgroundColor: colors.line,
                                pointBorderColor: '#ffffff',
                                pointBorderWidth: 2,
                                pointRadius: 4
                            },
                            {
                                label: 'Daily Activity',
                                data: timelineData.dailyActivity,
                                type: 'bar',
                                backgroundColor: colors.bars,
                                borderColor: colors.line,
                                borderWidth: 1,
                                yAxisID: 'y1',
                                maxBarThickness: 15
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `Badge Timeline Analysis - Risk Level: ${riskLevel}`,
                                color: '#e0e0e0',
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: {
                                labels: { color: '#e0e0e0' }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Timeline (Award Dates)',
                                    color: '#e0e0e0'
                                },
                                ticks: { color: '#ccc' },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Total Badges Earned',
                                    color: colors.line
                                },
                                ticks: { color: colors.line },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                beginAtZero: true
                            },
                            y1: {
                                type: 'linear',
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Daily Badge Count',
                                    color: colors.bars
                                },
                                ticks: { color: colors.bars },
                                grid: { drawOnChartArea: false },
                                beginAtZero: true
                            }
                        },
                        interaction: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                });
            }
        }
        
        // Initialize the advanced analyzer
        const analyzer = new AdvancedRobloxAnalyzer();
        
        // Form handling
        document.getElementById('analysisForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const username = document.getElementById('username').value.trim();
            
            if (!username) {
                alert('Please enter a target username for analysis.');
                return;
            }
            
            try {
                await analyzer.analyzeUser(username);
            } catch (error) {
                console.error('Analysis error:', error);
            }
        });
        
        // Enter key support
        document.getElementById('username').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('analysisForm').dispatchEvent(new Event('submit'));
            }
        });
    </script>
</body>
</html>
